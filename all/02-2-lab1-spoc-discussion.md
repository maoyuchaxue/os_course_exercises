# lab1 SPOC思考题

##**提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### 启动顺序

1. 段寄存器的字段含义和功能有哪些？

高13位为描述符索引，表示了其对应描述符在描述符表中的序号。

第2位为描述符表指示位(TI)，表示其对应的描述符表，为1表示使用LDT, 为0表示使用GDT.

第1-0位为RPL，指定了其特权级。

2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

DPL:表示待访问的代码段所需的特权级。 

CPL:表示当前代码段的特权级。

RPL:当前代码发出请求的特权级。

DPL存放在门描述符中，在调用门时进行检查；RPL存放在段描述符中，并会被加载入各段寄存器；CPL存放在当前的cs/ss中，原本段描述符中的RPL被加载到段寄存器时即成为当前的CPL.

访问条件：调用门要求MAX(CPL, RPL) <= DPL.

3. 分析可执行文件格式elf的格式（无需回答）

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1. 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

硬件压栈的内容根据是否跨特权级而不同。若不跨特权级，则压入error code, eip, cs, eflags. 若跨特权级，还压入esp, ss. 

2. 为什么在用户态的中断响应要使用内核堆栈？

中断属于内核代码范畴，若不使用内核权限，无法处理软硬件中断。因此中断时跨特权级，自然也需要切换到内核堆栈。

3. trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

其门描述符中有一位不同，用于区分两者；在处理上，interrupt gate进入后将屏蔽中断，而trap gate则不会。如果不做区分，则或都不屏蔽中断或都屏蔽中断，前者可能导致必要迫切的中断处理过程被打断，后者可能导致应当处理的中断没有被及时处理。

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析

1. 在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？

read\_ebp仅需要一个move指令就可以完成，因此内联就可以完成；而如果真的使用函数调用，反而会再压栈、自动修改ebp，读出来的ebp实际上是之前的esp,结果不对。

read\_eip则不同，用move eip是没有意义的，因为这些内嵌的汇编就已经修改了eip的值。只有在函数调用中被压入栈中的eip才有意义，因此需要用非内联函数，从栈里读出eip.

### 4.9 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？

是。CPU启动过程中BIOS有默认的中断处理程序，只是进入操作系统后被新的中断描述符表覆盖。

## 开放思考题

1. 如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？
2. 在lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
3. GRUB是一个通用的bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
4. 如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？

没有中断则外设时钟将无法如现在这样使用，外设也不能进行异步操作。如果想要完成功能，需要加入轮询与计数器，每执行一段代码，即前去轮询所有外设，判断是否发生中断，若发生，则跳转至对应的处理程序处理。这样能勉强实现功能，但是由于使用轮询来模拟异步，效率将大大降低。如果使用消息队列，那么无法完成进程的抢占，依然不好。

## 课堂实践
### 练习一
在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。

### 练习二
在ucore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。
