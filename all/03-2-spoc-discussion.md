# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
 1. 为什么要设计非连续内存分配机制？

连续内存分配有以下缺点：

+ 分配的物理内存必须连续，给实际实现带来困难；
+ 存在内碎片和外碎片，使得内存利用率低；
+ 内存分配难以动态修改，要维护起来比较麻烦。

 1. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

基本上有段式和页式两种选择，段式每块大小不定，页式的大小虽然可以进行选择，但是一旦选择需要保持一致，可以认为在一个进程内是不可变的。

 1. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

大块（段式）和小块（页式）的基本设计理念不同。段式粒度比较大，以一整段为单位进行处理，显然这些段不能确定长度，固定长度就会产生浪费，所以设置成可变；小块为了便于寻址、便于查找、便于分配空间，故设置成固定大小。

页帧的大小可以给出多种选择，但是一旦选择了其中一种以后，显然突然切换到另一种时，之前的页表数据都会失效（除非换了进程，整个页表也更换了）。所以，虽然可以选择大小，但在进程执行时不能随意修改。

### 6.2	段式存储管理
 1. 什么是段、段基址和段内偏移？

+ 段是**访问方式和存储数据等属性相同的一段地址空间**，对应着一段连续的内存块。
+ 段基址是段在内存中的起始地址，段内偏移是段内某一地址相对于段基址的位置。段内的程序只需关注段内偏移即可，cpu负责将其加上段基址得到实际地址。

 1. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

地址转换流程：访问时，硬件根据其当前的段号查找到段描述符，得到段基址和长度。接下来将段内偏移和段长度进行比较，判断是否超出段长。若未超出，则将段基址加上段内偏移得到实际地址。

段式存储管理中不同功能的各段可以分开，只需要分别设置好段基址，即可从各自的基址开始进行访问。这样的好处是较长的二进制文件被拆分成了几个小段，分配内存更加简单了，并且由于各段可以覆盖同一个物理段，因此也可以实现数据共享。麻烦在于加大了硬件成本，由于要保证段访问的安全性，速度也有一些损失。

### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

+ 页和帧都是空间的分配单位，不过帧是物理地址空间中的分配单位，而页是逻辑地址空间中的单位。
+ 页表是保存逻辑页到物理帧之间映射关系的数据结构，用于将逻辑地址转为物理地址。
+ MMU是负责进行地址转换的硬件。
+ TLB是页表查找结果的缓存，用于快速对最近常用的页进行查找和地址转换。
+ cache是内存的缓存，用于快速获取最近常用的地址中内存的值。

 1. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？

地址转换流程:

+ 根据逻辑地址，得到逻辑页号和页内偏移；
+ 根据页号查找TLB；
+ 若TLB缺失，前去查找页表；
+ 若页表中也缺失，即未分配物理页，则触发页缺失异常；
+ 查找到页表中的物理帧号，根据物理帧号|页内偏移得到物理地址。

各页具体的存储地址并不重要，只需要将各物理页的起始地址存在页表中即可实现定位，故没有连续存储的必要。

好处是：

+ 比起段粒度更小，交给连续内存分配算法的所有内存块请求大小相同，没有了内碎片这种问题；
+ 能够让一个程序仅用到的部分被加载入内存，更灵活；
+ 能够实现远超过物理地址大小的虚拟地址空间，同时不会对内存造成任何浪费；

也有对应的麻烦：

+ 由于页缺失时需要动态分配，空间不够时还需要换入换出，消耗比较大；
+ 每次访问都要查找页表，若是多级页表的话查找一次（TLB miss时）就要访问多次内存，开销很大；
+ 页表本身需要一些空间存储，比段所需要的信息多上很多。

不过麻烦都是在好处基础上新增的麻烦，所以并不是大问题。

### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

最泛用的页表项，至少需要包括物理帧号、存在位、修改位、引用位，其功能如下：

+ 存在位，表示该页表项是否现在存在，这用于判断该页是否在物理内存中；
+ 修改位，表示页面中的内容是否修改了，这用于更新对应的外存内容；
+ 引用位，表示过去一段时间内是否有对它的引用。

 1. 页表大小受哪些因素影响？

影响页表大小的包括虚拟地址字长L，单个页表项大小(不妨设为T字节)，页大小S。其页表占用空间`2^(L-S)*T`字节。

当然，如果使用二级页表或其他页表则另说。

### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

TLB是页表的缓存，cache是内存的缓存，两者使用在不同阶段。前者用在逻辑地址转物理地址时，存储的是物理帧号；后者用在从物理地址读数据时。存储的是内存的值。

 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

快表通过CPU内的专用硬件实现，由于布线近且硬件构成简单所以访问极快，而在CPU内不可能将规模做得很大，所以容量小。

 1. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

多级页表即将页分成层次，每层的页表都指向下一层页表的起始位置，形成树状结构；

地址转换流程：

+ 从逻辑地址中的高位，查找第一级页表；
+ 获得第一级页表中对应的第二级页表起始地址；
+ 在第二级页表中根据逻辑地址中中间一些位，查找对应的第三级页表；
+ …………
+ 从最低级页表中查找到对应的物理帧号。物理帧号加上页内偏移得到物理地址。

当然，其中每一步查找都有TLB、页缺失的处理步骤。

多级页表的好处在于将页表分成多段，未用到的页表部分可以无需生成，这样避免了逻辑地址太长导致的页表过大，存放不下的问题。

麻烦在于底层页表需要在使用时生成，并且地址转换所需经过的硬件更长了，速度更慢；用于处理的硬件规模也更大，功耗增大了。

### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？

地址转换流程是：

+ 根据逻辑地址，得到逻辑页号和页内偏移；
+ 对逻辑页号进行hash，得到hash值;
+ 将hash值在表中进行比对，若有冲突，则沿冲突链查找下去，找到pid和进程id相同，页号也相同的说明查找成功；
+ 查找成功时，得到对应的物理帧号，和页内偏移一同得到物理地址。

 1. 反置页表机制的地址转换流程是什么？

+ 根据逻辑地址，得到逻辑页号和页内偏移；
+ 对逻辑页号以及pid进行hash，得到hash值;
+ 将hash值在表中进行比对，得到在反置页表中的项；若有冲突，则沿冲突链查找下去，找到pid和进程id相同，页号也相同的说明查找成功；
+ 查找成功时，得到对应的物理帧号，和页内偏移一同得到物理地址。

 1. 反置页表项有些什么内容？

反置页表项包括三个部分：pid, vpn, next. 分别代表该物理页被使用的进程号、对应的虚拟页号、在冲突链上的下一个反置页表项地址。


### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

地址转换需要先后经过段、页两层转换，步骤如下:

+ 根据段选择子，查找到段表中的对应项；
+ 根据段表中的基地址和段长度，检查越界；
+ 将基地址与逻辑地址相加，得到线性地址；
+ 从线性地址取得逻辑页号和页偏移量；
+ 根据逻辑页号查询页表，得到物理帧号；
+ 物理帧号和页偏移量一同得到物理地址。

好处是能够结合段、页的优势：能够同时使用段的内存保护，页的内存利用率以及换入换出功能。麻烦是延迟相当于两者之和，硬件处理起来结构更加复杂了。

 1. 如何实现基于段式存储管理的内存共享？

只需要让不同的段基址指向同一内存地址，即相当于两段在物理上重合，完成了共享。

 1. 如何实现基于页式存储管理的内存共享？

可以让两个进程的页表相应项的物理帧号相同，这样即对应了同一块物理内存区域，完成内存共享。不过这里需要编译器链接器的配合，可共享的部分和不可共享的部分必须分隔开来，不能在同一页里。

## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的

学习了Intel的[这份白皮书](https://software.intel.com/sites/default/files/managed/2b/80/5-level_paging_white_paper.pdf)：

64位全部用于地址，将会导致或是规模庞大、不可承受的页表，或是过深、异常缓慢的多级页表硬件。因此，目前的方法(IA-32e)是64位中限制地址为最多48位，用四级页表实现，每级使用地址中的9位做为页号。当然，如上白皮书也在商讨使用五级页表来实现57位地址。

## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。

由

> 500ns = 150ns * 90% + x * 10%
> x = 3.65us

即不在内存的页面平均访问时间3.65us.

（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。


（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2018spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。
 
针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
